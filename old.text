use dirs::home_dir;
use image::{ImageBuffer, Rgba};
use std::fs;
use std::io::{self, Result};
use std::ptr;
use std::time::{SystemTime, UNIX_EPOCH};
use x11::xlib::*;

fn main() -> Result<()> {
    // Connect to the X11 server
    let display: *mut _XDisplay = unsafe { XOpenDisplay(ptr::null()) };
    if display.is_null() {
        eprintln!("Failed to open X11 display!!");
        return Ok(());
    }

    let screen: i32 = unsafe { XDefaultScreen(display) };
    let root_window = unsafe { XRootWindow(display, screen) };
    let width: i32 = unsafe { XDisplayWidth(display, screen) };
    let height: i32 = unsafe { XDisplayHeight(display, screen) };

    // Capture the screen
    let image: *mut XImage = unsafe {
        XGetImage(
            display,
            root_window,
            0,
            0,
            width as u32,
            height as u32,
            XAllPlanes(),
            ZPixmap,
        )
    };
    if image.is_null() {
        eprintln!("Failed to capture image!!");
        unsafe { XCloseDisplay(display) };
        return Ok(());
    }

    // Extract the image data into an ImageBuffer
    let img = extract_image_buffer(image);

    // Generate a filename with a timestamp
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time was backwards")
        .as_secs();
    let filename = format!("duck-shot-{}.png", timestamp);

    // Define the path to save the image
    let home = home_dir().expect("Failed to get home directory");
    let screenshots_dir = home.join("Pictures").join("Screenshots");
    if !screenshots_dir.exists() {
        fs::create_dir_all(&screenshots_dir)?;
    }
    let filepath = screenshots_dir.join(&filename);

    // Save the image
    img.save(&filepath)
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;

    // Clean up
    unsafe {
        XDestroyImage(image);
        XCloseDisplay(display);
    }

    println!("Screenshot saved as {:?}", filepath);

    Ok(())
}

// Function to get the pixel data from X11 image and convert to ImageBuffer
fn extract_image_buffer(image: *mut XImage) -> ImageBuffer<Rgba<u8>, Vec<u8>> {
    // Get image dimensions and bytes per pixel
    let width = unsafe { (*image).width as u32 };
    let height = unsafe { (*image).height as u32 };
    let bytes_per_pixel = unsafe { (*image).bits_per_pixel / 8 };
    let bytes_per_pixel_usize = bytes_per_pixel as usize;

    // Extract image data from X11
    let img_data: &[u8] = unsafe {
        std::slice::from_raw_parts(
            (*image).data as *const u8,
            (width * height * bytes_per_pixel as u32) as usize,
        )
    };

    // Create an ImageBuffer with the extracted pixel data
    let mut img = ImageBuffer::<Rgba<u8>, Vec<u8>>::new(width, height);
    for (x, y, pixel) in img.enumerate_pixels_mut() {
        let index = (y * width + x) as usize * bytes_per_pixel_usize;
        let chunk = &img_data[index..index + bytes_per_pixel_usize];
        *pixel = Rgba([chunk[2], chunk[1], chunk[0], 255]); // BGR to RGB conversion
    }

    img
}
